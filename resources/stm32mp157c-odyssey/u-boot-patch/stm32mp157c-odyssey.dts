// u-boot/arch/arm/dts/stm32mp157c-odyssey.dts
// SPDX-License-Identifier: (GPL-2.0+ OR BSD-3-Clause)
/*
 * Copyright (C) 2020 Marcin Sloniewski <marcin.sloniewski@gmail.com>
 */

/dts-v1/;

#include "stm32mp157c-odyssey-som.dtsi"

/ {

	model = "Seeed Studio Odyssey-STM32MP157C Board";
	compatible = "seeed,stm32mp157c-odyssey", "st,stm32mp157";

	aliases {
		ethernet0 = &ethernet0;
		serial0 = &uart4;
	};

	chosen {
		stdout-path = "serial0:115200n8";
	};

	led {
		compatible = "gpio-leds";
		blue {
			label = "heartbeat";
			gpios = <&gpiog 3 GPIO_ACTIVE_HIGH>;
			linux,default-trigger = "heartbeat";
			default-state = "off";
		};
	};

	firmware {
		optee: optee {
			compatible = "linaro,optee-tz";
			method = "smc";
		};

		scmi: scmi {
			compatible = "linaro,scmi-optee";
			#address-cells = <1>;
			#size-cells = <0>;
			linaro,optee-channel-id = <0>;

			scmi_clk: protocol@14 {
				reg = <0x14>;
				#clock-cells = <1>;
			};

			scmi_reset: protocol@16 {
				reg = <0x16>;
				#reset-cells = <1>;
			};
		};
	};
};

&pinctrl {
	ltdc_pins_s: ltdc-4 {
		pins {
			pinmux = <STM32_PINMUX('G',  7, AF14)>, /* LCD_CLK */
				 <STM32_PINMUX('I', 10, AF14)>, /* LCD_HSYNC */
				 <STM32_PINMUX('I',  9, AF14)>, /* LCD_VSYNC */
				 <STM32_PINMUX('F', 10, AF14)>, /* LCD_DE */
				 <STM32_PINMUX('H',  2, AF14)>, /* LCD_R0 */
				 <STM32_PINMUX('H',  3, AF14)>, /* LCD_R1 */
				 <STM32_PINMUX('H',  8, AF14)>, /* LCD_R2 */
				 <STM32_PINMUX('H',  9, AF14)>, /* LCD_R3 */
				 <STM32_PINMUX('A',  5, AF14)>, /* LCD_R4 */
				 <STM32_PINMUX('C',  0, AF14)>, /* LCD_R5 */
				 <STM32_PINMUX('H', 12, AF14)>, /* LCD_R6 */
				 <STM32_PINMUX('E', 15, AF14)>, /* LCD_R7 */
				 <STM32_PINMUX('E', 14, AF14)>, /* LCD_G0 */
				 <STM32_PINMUX('E',  6, AF14)>, /* LCD_G1 */
				 <STM32_PINMUX('H', 13, AF14)>, /* LCD_G2 */
				 <STM32_PINMUX('H', 14, AF14)>, /* LCD_G3 */
				 <STM32_PINMUX('H', 15, AF14)>, /* LCD_G4 */
				 <STM32_PINMUX('I',  0, AF14)>, /* LCD_G5 */
				 <STM32_PINMUX('I',  1, AF14)>, /* LCD_G6 */
				 <STM32_PINMUX('I',  2, AF14)>, /* LCD_G7 */
				 <STM32_PINMUX('D',  9, AF14)>, /* LCD_B0 */
				 <STM32_PINMUX('G', 12, AF14)>, /* LCD_B1 */
				 <STM32_PINMUX('G', 10, AF14)>, /* LCD_B2 */
				 <STM32_PINMUX('D', 10, AF14)>, /* LCD_B3 */
				 <STM32_PINMUX('I',  4, AF14)>, /* LCD_B4 */
				 <STM32_PINMUX('A',  3, AF14)>, /* LCD_B5 */
				 <STM32_PINMUX('B',  8, AF14)>, /* LCD_B6 */
				 <STM32_PINMUX('D',  8, AF14)>; /* LCD_B7 */
			bias-disable;
			drive-push-pull;
			slew-rate = <1>;
		};
	};

	ltdc_sleep_pins_s: ltdc-sleep-4 {
		pins {
			pinmux = <STM32_PINMUX('G',  7, ANALOG)>, /* LCD_CLK */
				 <STM32_PINMUX('I', 10, ANALOG)>, /* LCD_HSYNC */
				 <STM32_PINMUX('I',  9, ANALOG)>, /* LCD_VSYNC */
				 <STM32_PINMUX('F', 10, ANALOG)>, /* LCD_DE */
				 <STM32_PINMUX('H',  2, ANALOG)>, /* LCD_R0 */
				 <STM32_PINMUX('H',  3, ANALOG)>, /* LCD_R1 */
				 <STM32_PINMUX('H',  8, ANALOG)>, /* LCD_R2 */
				 <STM32_PINMUX('H',  9, ANALOG)>, /* LCD_R3 */
				 <STM32_PINMUX('A',  5, ANALOG)>, /* LCD_R4 */
				 <STM32_PINMUX('C',  0, ANALOG)>, /* LCD_R5 */
				 <STM32_PINMUX('H', 12, ANALOG)>, /* LCD_R6 */
				 <STM32_PINMUX('E', 15, ANALOG)>, /* LCD_R7 */
				 <STM32_PINMUX('E', 14, ANALOG)>, /* LCD_G0 */
				 <STM32_PINMUX('E',  6, ANALOG)>, /* LCD_G1 */
				 <STM32_PINMUX('H', 13, ANALOG)>, /* LCD_G2 */
				 <STM32_PINMUX('H', 14, ANALOG)>, /* LCD_G3 */
				 <STM32_PINMUX('H', 15, ANALOG)>, /* LCD_G4 */
				 <STM32_PINMUX('I',  0, ANALOG)>, /* LCD_G5 */
				 <STM32_PINMUX('I',  1, ANALOG)>, /* LCD_G6 */
				 <STM32_PINMUX('I',  2, ANALOG)>, /* LCD_G7 */
				 <STM32_PINMUX('D',  9, ANALOG)>, /* LCD_B0 */
				 <STM32_PINMUX('G', 12, ANALOG)>, /* LCD_B1 */
				 <STM32_PINMUX('G', 10, ANALOG)>, /* LCD_B2 */
				 <STM32_PINMUX('D', 10, ANALOG)>, /* LCD_B3 */
				 <STM32_PINMUX('I',  4, ANALOG)>, /* LCD_B4 */
				 <STM32_PINMUX('A',  3, ANALOG)>, /* LCD_B5 */
				 <STM32_PINMUX('B',  8, ANALOG)>, /* LCD_B6 */
				 <STM32_PINMUX('D',  8, ANALOG)>; /* LCD_B7 */
		};
	};
}

&adc {
	pinctrl-names = "default";
	pinctrl-0 = <&adc12_ain_pins_a>, <&adc12_usb_cc_pins_a>;
	vdd-supply = <&vdd>;
	vdda-supply = <&vdd>;
	vref-supply = <&vrefbuf>;
	status = "disabled";
	adc1: adc@0 {
		/*
		 * Type-C USB_PWR_CC1 & USB_PWR_CC2 on in18 & in19.
		 * Use at least 5 * RC time, e.g. 5 * (Rp + Rd) * C:
		 * 5 * (56 + 47kOhms) * 5pF => 2.5us.
		 * Use arbitrary margin here (e.g. 5us).
		 */
		st,min-sample-time-nsecs = <5000>;
		/* AIN connector, USB Type-C CC1 & CC2 */
		st,adc-channels = <0 1 6 13 18 19>;
		status = "okay";
	};
	adc2: adc@100 {
		/* AIN connector, USB Type-C CC1 & CC2 */
		st,adc-channels = <0 1 2 6 18 19>;
		st,min-sample-time-nsecs = <5000>;
		status = "okay";
	};
};

&cec {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&cec_pins_b>;
	pinctrl-1 = <&cec_sleep_pins_b>;
	status = "okay";
};

&ethernet0 {
	status = "okay";
	pinctrl-0 = <&ethernet0_rgmii_pins_a>;
	pinctrl-1 = <&ethernet0_rgmii_sleep_pins_a>;
	pinctrl-names = "default", "sleep";
	phy-mode = "rgmii-id";
	max-speed = <1000>;
	phy-handle = <&phy0>;
	st,eth-clk-sel;
	phy-reset-gpios = <&gpiog 0 GPIO_ACTIVE_LOW>;

	mdio0 {
		status = "okay";
		#address-cells = <1>;
		#size-cells = <0>;
		compatible = "snps,dwmac-mdio";

		phy0: ethernet-phy@7 {
			reg = <7>;
			reset-gpios = <&gpiog 0 GPIO_ACTIVE_LOW>;
			reset-assert-us = <11000>;
			reset-deassert-us = <1000>;
		};
	};
};

&gpu {
	contiguous-area = <&gpu_reserved>;
	status = "okay";
};

&i2c1 {
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2c1_pins_a>;
	pinctrl-1 = <&i2c1_sleep_pins_a>;
	i2c-scl-rising-time-ns = <100>;
	i2c-scl-falling-time-ns = <7>;
	status = "okay";
	/delete-property/dmas;
	/delete-property/dma-names;
};

&i2s2 {
	clocks = <&rcc SPI2>, <&rcc SPI2_K>, <&rcc PLL3_Q>, <&rcc PLL3_R>;
	clock-names = "pclk", "i2sclk", "x8k", "x11k";
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&i2s2_pins_a>;
	pinctrl-1 = <&i2s2_sleep_pins_a>;
	status = "okay";
};

&pwr_regulators {
	vdd-supply = <&vdd>;
	vdd_3v3_usbfs-supply = <&vdd_usb>;
};

&sdmmc1 {
	pinctrl-names = "default", "opendrain", "sleep";
	pinctrl-0 = <&sdmmc1_b4_pins_a>;
	pinctrl-1 = <&sdmmc1_b4_od_pins_a>;
	pinctrl-2 = <&sdmmc1_b4_sleep_pins_a>;
	broken-cd;
	disable-wp;
	st,neg-edge;
	bus-width = <4>;
	vmmc-supply = <&v3v3>;
	status = "okay";
};

&uart4 {
	pinctrl-names = "default";
	pinctrl-0 = <&uart4_pins_a>;
	/delete-property/dmas;
	/delete-property/dma-names;
	status = "okay";
};

&usbh_ehci {
	phys = <&usbphyc_port0>;
	status = "okay";
};

&usbotg_hs {
	dr_mode = "peripheral";
	phys = <&usbphyc_port1 0>;
	phy-names = "usb2-phy";
	status = "okay";
};

&usbphyc {
	status = "okay";
};

&usbphyc_port0 {
	phy-supply = <&vdd_usb>;
};

&usbphyc_port1 {
	phy-supply = <&vdd_usb>;
};

&dsi {
	#address-cells = <1>;
	#size-cells = <0>;
	status = "okay";

	panel_otm8009a: panel-otm8009a@0 {
		compatible = "orisetech,otm8009a";
		reg = <0>;
		reset-gpios = <&gpioe 4 GPIO_ACTIVE_LOW>;
		power-supply = <&v3v3>;
		default-on;
		status = "okay";

		port {
			panel_in: endpoint {
				remote-endpoint = <&dsi_out>;
			};
		};
	};
};

&dsi_in {
	remote-endpoint = <&ltdc_ep0_out>;
};

&dsi_out {
	remote-endpoint = <&panel_in>;
};

&ltdc {
	default-on;
	pinctrl-names = "default", "sleep";
	pinctrl-0 = <&ltdc_pins_s>;
	pinctrl-1 = <&ltdc_sleep_pins_s>;
	status = "okay";

	port {
		#address-cells = <1>;
		#size-cells = <0>;

		ltdc_ep0_out: endpoint {
			remote-endpoint = <&dsi_in>;
		};
	};
};
